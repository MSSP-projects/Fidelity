#     for m=1:k+1;
#         y(k+1)=y(k+1)+(1/(k+1))*rca(m,k-m+2);
#     end
# end
# %重构 Lp~Kp
# for k=Lp-1:Kp-1
#     for m=1:Lp;
#         y(k+1)=y(k+1)+(1/(Lp))*rca(m,k-m+2);
#     end
# end
# %重构 Kp+1~N
# for k=Kp:N-1
#     for m=k-Kp+2:N-Kp+1;
#         y(k+1)=y(k+1)+(1/(N-k))*rca(m,k-m+2);
#     end
# end
#
# signalFiltered = y;
# end
# function [signalFiltered]=SSA(signal,windowLen)
# # %========================================================================
# # % signal 原始信号
# # % windowLen 窗口长度
# # % signalFiltered   重构时间序列
# # %=========================================================================
# # % Step1 : 建立轨迹矩阵
N=length(x2),
# function [signalFiltered]=SSA(signal,windowLen)
# # %========================================================================
# # % signal 原始信号
# # % windowLen 窗口长度
# # % signalFiltered   重构时间序列
# # %=========================================================================
# # % Step1 : 建立轨迹矩阵
N=length(x2)
N
windowLen=30
365/53
53/7
K=N-windowLen+1
K
X=matrix(0,windowLen,K)
for (i in 1:K){
X[1:windowLen,i] <- x2(i:windowLen+i-1)
}
X[1:windowLen,i] <- x2[i:windowLen+i-1]
for (i in 1:K){
X[1:windowLen,i] <- x2[i:windowLen+i-1]
}
for (i in 1:K){
X[1:30,i] <- x2[i:windowLen+i-1]
}
for (i in 1:K){
X[,i] <- x2[i:windowLen+i-1]
}
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
x2
View(x2)
x2 <- as.numeric(x2)
## matrix:30*701,xxt 30*30, number of eigenvalues is 30. DECOMPOSITION.
s <- ssa(x2, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
plot(r, add.original = TRUE) # Plot the reconstruction
s$sigma
s$U
r$trend
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(s, type = "vectors", idx = 1:8)
plot(s, type = "paired", idx = 2:11, plot.contrib = FALSE)
print(parestimate(s, groups = list(2:3, 4:5),
method = "pairs"))
#print(parestimate(s, groups = list(2:3, 4:5),
#  method = "pairs"))
plot(wcor(s, groups = 1:30),
scales = list(at = c(10, 20, 30)))
plot(reconstruct(s, groups = list(G12 = 2:3, G4 = 4:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
# s$U
# s$V
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
plot(s, type = "vectors", idx = 1:8)
plot(s, type = "paired", idx = 2:11, plot.contrib = FALSE)
#print(parestimate(s, groups = list(2:3, 4:5),
#  method = "pairs"))
plot(wcor(s, groups = 1:30),
scales = list(at = c(10, 20, 30)))
plot(reconstruct(s, groups = list(G12 = 2:3, G4 = 4:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
plot(reconstruct(s, groups = list(G12 = 1:2, G4 = 3:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
plot(reconstruct(s, groups = list(G12 = 1, G4 = 3:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
plot(reconstruct(s, groups = list(G12 = 1, G4 = 2:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
summary(s)
plot(s)
s$sigma #singular values
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
r
plot(s, type = "vectors", idx = 1:8) #main eigenvalue is only one, what is it?
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:8) #main eigenvalue is only one, what is it?
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, Seasonality=c(3:8)))
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:8) #main eigenvalue is only one, what is it?
# s$U
# s$V
plot(s, type = "vectors", idx = 1:12) #main eigenvalue is only one, what is it?
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #main eigenvalue is only one, what is it?
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, Seasonality=c(3:15)))
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
#
plot(s, type = "paired", idx = 2:11, plot.contrib = FALSE)
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
## matrix:30*701,xxt 30*30, number of eigenvalues is 30. DECOMPOSITION.
s <- ssa(x2, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, Seasonality=c(3:15)))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:15) #two main eigenvalue are trends, what is it?
knitr::opts_chunk$set(echo = TRUE)
#install.packages("leaflet")
library(leaflet)
knitr::opts_chunk$set(echo = TRUE)
#install.packages("leaflet")
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=-123.542880, lat=39.377740, popup="The birthplace of R")
m  # Print the map
knitr::opts_chunk$set(echo = TRUE)
x <- filter(df_day,NEWID==283)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(datetime)
library(lubridate)
library(dplyr)
library(reshape2)
x <- filter(df_day,NEWID==283)
View(df_day)
View(dup.list)
View(dup.check)
View(ID_CROSSWALK)
y <- filter(df_day,NEWID==9)
library(tidyverse)
library(tidyr)
library(datetime)
library(lubridate)
library(dplyr)
library(reshape2)
df <- read.csv("warehouse_credit_cleansed.csv", header = T)
df <- arrange(df, WAREHOUSE_NAME)
# create new ID
ids <-distinct(data.frame(df$WAREHOUSE_NAME)) %>% rename(WAREHOUSE_NAME =  df.WAREHOUSE_NAME )
ID_CROSSWALK <- ids %>% mutate( NEWID = row_number())
df <- full_join(df,ID_CROSSWALK, by ="WAREHOUSE_NAME")
df <- df[,c("NEWID","WAREHOUSE_METERING_START_TIME", "ACTUAL_CREDITS", "EXECUTION_CREDITS", "EFFECTIVE_EXECUTION_CREDITS")]
df <- arrange(df, NEWID, WAREHOUSE_METERING_START_TIME)
# wipe out duplicated data - Note: this may change once we get more information from Bob and Brian
dup.no <- which(duplicated(df[, c("NEWID","WAREHOUSE_METERING_START_TIME")]))
dup.list <- df[, c("NEWID","WAREHOUSE_METERING_START_TIME")][dup.no, ]
dup.check <- data.frame(matrix(nrow = 0 , ncol = 5))
colnames(dup.check ) <- colnames(df)
for(i in 1:length(dup.list$NEWID)){
dup.check <- rbind(dup.check, filter(df, NEWID == dup.list$NEWID[i] & WAREHOUSE_METERING_START_TIME == dup.list$WAREHOUSE_METERING_START_TIME[i]))
}
df <- df[-dup.no, ]
df$WAREHOUSE_METERING_START_TIME <- as.character(as_datetime(df$WAREHOUSE_METERING_START_TIME))
arrange(count(df, NEWID), desc(n))
for(i in 1: dim(dup.check)[1]){
# i = 1
dup.list = rbind(filter(ID_CROSSWALK, NEWID == dup.check$NEWID[i]), dup.list)
}
dup.list <- distinct(dup.list)
# create the complete time line from 2019/08/01/00:00:00 to 2021/08/02/05:00:00
diff_hour <- as.numeric(difftime(as_datetime("2021-08-02 04:00:00"), as_datetime("2019-08-01 00:00:00"), units = c("hours")))
out <- ISOdatetime(2019,07,31,20,0,0) + (0:diff_hour) *60*60
attr(out, "tzone") <- "UTC"
time_index <- as.character(out)
time_index[17573]
# cast ACTUAL, EXECUTION, EFFECTIVE EXECUTION CREDITS of 'df' onto created time index
df_actual <- dcast(df, NEWID ~ WAREHOUSE_METERING_START_TIME, value.var = "ACTUAL_CREDITS")
df_execution <- dcast(df, NEWID ~ WAREHOUSE_METERING_START_TIME, value.var = "EXECUTION_CREDITS")
df_effective_execution <- dcast(df, NEWID ~ WAREHOUSE_METERING_START_TIME, value.var = "EFFECTIVE_EXECUTION_CREDITS")
####################################################################################
add_time <- function(df, timeline){
# df <- df_actual
# timeline <- time_index
output <- data.frame(matrix(, nrow = dim(df)[1], ncol = length(timeline)))
colnames(output) <- timeline
for (j in 1: length(timeline)) {
if(is.element(timeline[j], colnames(df))){
output[, j] <- df[, match(timeline[j], colnames(df))]
}else{
output[, j] <- output[, j]
}
}
output <- cbind(NEWID = df[, c("NEWID")], output)
return(output)
}
subset(df_actual, NEWID == 283)
df_actual <- add_time(df_actual, timeline = time_index)
df_execution <- add_time(df_execution, timeline = time_index)
df_effective_execution <- add_time(df_effective_execution, timeline = time_index)
subset(df_actual, NEWID == 283)
# create an index from 2019-08-01 00:00:00 to 2021-08-01 23:00:00
diff_hour1 <- as.numeric(difftime(as_datetime("2021-08-01 23:00:00"), as_datetime("2019-08-01 00:00:00"), units = c("hours")))
out1 <- ISOdatetime(2019,07,31,20,0,0) + (0:diff_hour1) *60*60
attr(out1, "tzone") <- "UTC"
time_index_1 <- as.character(out1)
time_index_1 <- c("NEWID", time_index_1)
df_actual_1 <- df_actual[, time_index_1] %>% melt(c("NEWID"))
df_execution_1 <- df_execution[, time_index_1] %>% melt(c("NEWID"))
df_effective_execution_1 <- df_effective_execution[, time_index_1] %>% melt(c("NEWID"))
df_actual_1$variable <- as_date(df_actual_1$variable)
df_execution_1$variable <- as_date(df_execution_1$variable)
df_effective_execution_1$variable <- as_date(df_effective_execution_1$variable)
# replace 'NA' with '0'
df_actual_1[is.na(df_actual_1)] <- 0
df_execution_1[is.na(df_execution_1)] <- 0
df_effective_execution_1[is.na(df_effective_execution_1)] <- 0
colnames(df_actual_1) <- c("NEWID", "date", "credits")
colnames(df_execution_1) <- c("NEWID", "date", "credits")
colnames(df_effective_execution_1) <- c("NEWID", "date", "credits")
actual_daily <- df_actual_1 %>% group_by(NEWID, date) %>% summarise(sum = sum(credits)) %>%  add_column(type ="ACTUAL_CREDITS",.after =1)
execution_daily <- df_execution_1 %>% group_by(NEWID, date) %>% summarise(sum = sum(credits)) %>% add_column(type = "EXECUTION_CREDITS",.after =1)
effective_execution_daily <- df_effective_execution_1 %>% group_by(NEWID, date) %>% summarise(sum = sum(credits)) %>% add_column(type ="EFFECTIVE_EXECUTION_CREDITS",.after =1)
View(execution_daily)
diff_hour <- as.numeric(difftime(as_datetime("2021-08-02 04:00:00"), as_datetime("2019-08-01 00:00:00"), units = c("hours")))
out <- ISOdatetime(2019,07,31,20,0,0) + (0:diff_hour) *60*60
attr(out, "tzone") <- "UTC"
time_index <- as.character(out)
time_index[17573]
# cast ACTUAL, EXECUTION, EFFECTIVE EXECUTION CREDITS of 'df' onto created time index
df_actual <- dcast(df, NEWID ~ WAREHOUSE_METERING_START_TIME, value.var = "ACTUAL_CREDITS")
df_execution <- dcast(df, NEWID ~ WAREHOUSE_METERING_START_TIME, value.var = "EXECUTION_CREDITS")
df_effective_execution <- dcast(df, NEWID ~ WAREHOUSE_METERING_START_TIME, value.var = "EFFECTIVE_EXECUTION_CREDITS")
y1 <- filter(df_day,NEWID==130)
y1 <- filter(df_day,NEWID==252)
y1 <- filter(df_day,NEWID==106)
y1 <- filter(df_day,NEWID==53)
y1 <- filter(df_day,NEWID==33)
y$date <- paste(y$year,y$day)
y1$date <- paste(y1$year,y1$day)
cons <- left_join(y1,y,by="date")
View(cons)
cons <- inner_join(y1,y,by="date")
View(cons)
cons1 <- cons[,c(1,8,6,13)]
knitr::opts_chunk$set(echo = TRUE)
x <- filter(df_day,NEWID==283)
x1 <- x[,c(6)]
# x2 <- vector()
# for (i in 1:730){
#   x2[i]<- x1[i,1]
# }
x1 <- as.numeric(x1)
View(cons1)
knitr::opts_chunk$set(echo = TRUE)
x <- filter(df_day,NEWID==283)
x1 <- x[,c(6)]
x2 <- vector()
for (i in 1:730){
x2[i]<- x1[i,1]
}
x2 <- as.numeric(x1)
knitr::opts_chunk$set(echo = TRUE)
x <- filter(df_day,NEWID==283)
x1 <- x[,c(6)]
x2 <- vector()
for (i in 1:730){
x2[i]<- x1[i,1]
}
#x2 <- as.numeric(x1)
s2 <- ssa(cons1[, 3] + 1i*cons1[, 4], + kind = "cssa", svd.method = "svd")
s2 <- ssa(cons1[, 3] + 1i*cons1[, 4],  kind = "cssa", svd.method = "svd")
library(Rssa)
s2 <- ssa(cons1[, 3] + 1i*cons1[, 4],  kind = "cssa", svd.method = "svd")
cons2 <- cons[,c(6,13)]
summary(cons2)
norm.cons2 <- sqrt(colMeans(wineFortRose^2))
norm.cons2 <- sqrt(colMeans(cons2^2))
norm.cons2n <- sqrt(colMeans(cons2^2))
cons2n <-sweep(cons2, 2, norm.cons2n, "/")
L <- 30
s.cons2n <- ssa(cons2n, L = L, kind = "mssa")
s.cons2 <- ssa(cons2, L = L, kind = "mssa")
r.cons2n <- reconstruct(s.cons2n,
groups = list(Trend = c(1, 12, 14), Seasonality = c(2:11, 13)))
r.cons2 <- reconstruct(s.cons2, groups = list(Trend = 1, Seasonality = 2:11))
wrap.plot <- function(rec, component = 1, series, xlab = "", ylab, ...)
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE,
scales = list(y = list(tick.number = 3)), slice = list(component = component, series = series)
auto.key = list(columns = 2))
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE,
scales = list(y = list(tick.number = 3)), slice = list(component = component, series = series)
auto.key = "")
wrap.plot <- function(rec, component = 1, series, xlab = "", ylab, ...)
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
xlab=xlab, ylab=ylab, auto.key = "",...)
trel1 <- wrap.plot(r.cons2n, series = 2, ylab = "Rose, norm", main = NULL)
trel1 <- wrap.plot(r.cons2n, series = 2, ylab = "Rose, norm", main = NULL)
trel2 <- wrap.plot(r.cons2n, series = 1, ylab = "Fort, norm", main = NULL)
trel3 <- wrap.plot(r.cons2, series = 2, ylab = "Rose", main = NULL)
trel4 <- wrap.plot(r.cons2, series = 1, ylab = "Fort", main = NULL)
plot(trel1, split = c(1, 1, 2, 2), more = TRUE)
trel1 <- wrap.plot(x=r.cons2n, series = 2, ylab = "Rose, norm", main = NULL)
r.cons2n
norm.cons2n
cons2n
s.cons2n
r.cons2
wrap.plot <- function(rec, component = 1, series, xlab = "", ylab, ...)
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
xlab=xlab, ylab=ylab, auto.key = "",...)
wrap.plot <- function(rec, component = 1, series, xlab = "", ylab, ...)
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
xlab=xlab, ylab=ylab, auto.key = "",...)
trel1 <- wrap.plot(r.cons2n, series = 2, ylab = "Rose, norm", main = NULL)
plot(r.cons2,add.original = TRUE)
plot(r.cons2n,add.original = TRUE)
wrap.plot <- function(rec, component = 1, series, xlab = "", ylab, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
xlab=xlab, ylab=ylab, auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, ylab = "Rose, norm", main = NULL)
wrap.plot <- function(rec, component = 1, series, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
xlab=xlab, ylab=ylab, auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, main = NULL)
#plot(r.cons2n,add.original = TRUE)
plot(r.cons2n, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
wrap.plot <- function(rec, component = 1, series, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, main = NULL)
r.cons2n
norm.cons2n
wrap.plot <- function(rec, component = 1, series, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "ntbt_xyplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, main = NULL)
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "matplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
auto.key = "",...)}
wrap.plot <- function(rec, component = 1, series, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "matplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, main = NULL)
wrap.plot <- function(rec, component = 1, series, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "native", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, main = NULL)
wrap.plot <- function(rec, component = 1, series, ...){
plot(rec, add.residuals = FALSE, add.original = TRUE,
plot.method = "matplot", superpose = TRUE,
scales = list(y = list(tick.number = 3)),
slice = list(component = component, series = series),
auto.key = "",...)}
trel1 <- wrap.plot(r.cons2n, series = 2, main = NULL)
library(readr)
AustralianWine <- read_csv("AustralianWine.rda")
View(AustralianWine)
AustralianWine <- read_rda("AustralianWine.rda")
AustralianWine <- read.rda("AustralianWine.rda")
library(dplyr)
AustralianWine <- read.rda("AustralianWine.rda")
AustralianWine <- load("AustralianWine.rda")
View(AustralianWine)
AustralianWine
library(dplyr)
load("AustralianWine.rda")
View(AustralianWine)
AustralianWine <- load("AustralianWine.rda")
load("AustralianWine.rda")
library(dplyr)
load("AustralianWine.rda")
AustralianWine<-AustralianWine
View(AustralianWine)
AustralianWine <- cons[,c(3,5)]
norm.AustralianWinen <- sqrt(colMeans(AustralianWine^2))
AustralianWinen <-sweep(AustralianWine, 2, AustralianWinen, "/")
norm.AustralianWinen <- sqrt(colMeans(AustralianWine^2))
dim(norm.AustralianWinen)
length(norm.AustralianWinen)
norm.AustralianWinen
dim(AustralianWinen)
length(AustralianWinen)
