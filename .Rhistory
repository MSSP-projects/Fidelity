round(summary(model2)$coef,2)
fitted(model2)
cor(model2[, 2:4], method = "pearson")
residuals(model2, type = "response")
residuals(model2, type = "Pearson")
model2.3 <- polr(level~placebo+vaccine,data=b,Hess=TRUE)
summary(model2.3)
ggplot(melt(b,id.vars=c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point()+
aes(x=variable,y=value,color=level)+
facet_wrap(~placebo)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(~placebo)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(~vaccine)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(placebo~vaccine)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(~vaccine)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_line(aes(x=variable,y=value,color=level))+
facet_wrap(~vaccine)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_line(aes(x=variable,y=value,color=level))
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_line(aes(x=x,y=value,color=variable))
ggplot(melt(dt2b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(~placebo)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(~placebo)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
facet_wrap(~vaccine)
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
geom_jitter()
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
geom_jitter(aes(x=variable,y=value,color=level))
ggplot(melt(b,id.vars = c("placebo","vaccine")))+
geom_point(aes(x=variable,y=value,color=level))+
geom_jitter(aes(x=variable,y=value,color=level))+
facet_wrap(~vaccine)
data(hsb)
?hsb
colnames(hsb)
model3 <- polr(prog~race,data=hsb,Hess=TRUE)
model3 <- polr(prog~gender+race+ses+read,data=hsb,Hess=TRUE)
summary(model3)
hsbsub <- filter(hsb,id==99)
predict(model3,newdata=hsbsub,type="probs")
library(faraway)
data(happy)
?happy
model4 <- polr(factor(happy)~money+factor(sex)+factor(love)+factor(work), data=happy, Hess=TRUE)
summary(model4)
exp(coef(model4))
exp(coef(model4))
exp(coef(model4))
summary(model4)
predict(model4,newdata=data.frame(love=1,sex=0,work=1,money=30),type="probs")
data(uncviet)
?uncviet
library(faraway)
data(pneumo,package="faraway")
?pneumo
model5 <- polr(policy ~ sex+year, data=uncviet, Hess=TRUE)
summary(m5)
summary(model5)
model6 = multinom(status~year,weights=Freq,data=pneumo)
summary(model6)
pre1 = predict(model6,newdata=data.frame(year=25),type = "probs")
predict(model6,newdata=data.frame(year=25),type = "probs")
predict(model6.2,newdata=data.frame(year=25),type = "probs")
model6.2 = polr(status~year,weights=Freq,data=pneumo)
summary(model6.2)
predict(model6.2,newdata=data.frame(year=25),type = "probs")
pneumo$status <- factor(pneumo$status,levels=c("normal","mild","severe"),ordered=TRUE)
model6.3 <- polr(status~year,weights=Freq,data=pneumo,Hess=TRUE)
summary(model6.3)
predict(model6.3,newdata=list(year =25),type="probs")
AIC(model6.1)
AIC(model6)
AIC(model6.2)
AIC(model6.3)
knitr::opts_chunk$set(echo = TRUE,out.width="0.9\\linewidth",dev="pdf",fig.align  = 'center')
pacman::p_load(
"ggplot2",
"knitr",
"arm",
"data.table",
"foreign",
"car",
"faraway",
"nnet",
"reshape2",
"VGAM"
)
nes <- read.dta("~/Downloads/nes5200_processed_voters_realideo.dta")
colnames(nes)
nes2000 <- filter(nes,year==2000 )
#colnames(nes)
nes2000 <- filter(nes,year=2000 )
#colnames(nes)
nes2000 <- filter(nes,year==2000 )
#colnames(nes)
nes <- data.table(nes)
pacman::p_load(
"ggplot2",
"knitr",
"arm",
"data.table",
"foreign",
"car",
"faraway",
"nnet",
"reshape2",
"VGAM",
"dplyr"
)
resid <-dcast(nes2000a, age + ideo ~ partyid3)
resid <- model.matrix(~ factor(partyid3) - 1, data = nes2000a) - fitted(model1)
nes2000b = cbind(partyid3=nes2000a$partyid3, age=nes2000a$age, ideo=nes2000a$ideo)
resid <- model.matrix(~ factor(partyid3)-1, data = nes2000b) - fitted(model1)
nes2000b <- data.frame(nes2000b)
resid <- model.matrix(~ factor(partyid3)-1, data = nes2000b) - fitted(model1)
source(EDA3.Rmd)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(datetime)
library(lubridate)
library(dplyr)
library(reshape2)
df <- read.csv("warehouse_credit_cleansed.csv", header = T)
df <- arrange(df, WAREHOUSE_NAME)
# create new ID
ids <-distinct(data.frame(df$WAREHOUSE_NAME)) %>% rename(WAREHOUSE_NAME =  df.WAREHOUSE_NAME )
ID_CROSSWALK <- ids %>% mutate( NEWID = row_number())
df <- full_join(df,ID_CROSSWALK, by ="WAREHOUSE_NAME")
df <- arrange(df, NEWID, WAREHOUSE_METERING_START_TIME)
df <- df[,c("NEWID","WAREHOUSE_METERING_START_TIME", "ACTUAL_CREDITS", "EXECUTION_CREDITS", "EFFECTIVE_EXECUTION_CREDITS")]
df <- arrange(df, NEWID, WAREHOUSE_METERING_START_TIME)
# wipe out duplicated data
dup.no <- which(duplicated(df[, c("NEWID","WAREHOUSE_METERING_START_TIME")]))
dup.list <- df[, c("NEWID","WAREHOUSE_METERING_START_TIME")][dup.no, ]
dup.check <- data.frame(matrix(nrow = 0 , ncol = 6))
colnames(dup.check ) <- colnames(df)
for(i in 1:length(dup.list$NEWID)){
dup.check <- rbind(dup.check, filter(df, NEWID == dup.list$NEWID[i] & WAREHOUSE_METERING_START_TIME == dup.list$WAREHOUSE_METERING_START_TIME[i]))
}
df <- df[-dup.no, ]
library(data.table)
df$year <- year(df$WAREHOUSE_METERING_START_TIME)
df$month <- month(df$WAREHOUSE_METERING_START_TIME)
df$week <- week(df$WAREHOUSE_METERING_START_TIME)
df$day <- yday(df$WAREHOUSE_METERING_START_TIME)
## creat day unit dataset
df_day <- df %>%
group_by(NEWID,year,day) %>%
summarise(ACTUAL_CREDITS=sum(ACTUAL_CREDITS),EXECUTION_CREDITS=sum(EXECUTION_CREDITS),averageEfficiency=EXECUTION_CREDITS/ACTUAL_CREDITS)
#error <- filter(df_day,averageEfficiency=="Inf")
df_day <- df_day[!(df_day$averageEfficiency=="Inf"),]
df_day <- arrange(df_day,year,day)
df_day
find.package(ssa)
find.package("ssa")
find.package("Rssa")
install.packages("ssa")
install.packages("Rssa")
library(Rssa)
library(ssa)
View(df_day)
x <- filter(df_day,NEWID==106)
View(x)
View(df_day)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
warehouse_credit_cleansed <- read.csv("~/Desktop/BU-2021fall/MA675-stat pract/partner project/fidelity-1/warehouse_credit_cleansed.csv",header = TRUE)
(warehouse_count <- warehouse_credit_cleansed %>%
group_by(WAREHOUSE_NAME) %>%
summarise(usage_time=n()))
View(warehouse_count)
View(ids)
View(ID_CROSSWALK)
x <- filter(df_day,NEWID==283)
View(x)
View(x)
x1 <- x[,c(1,2,6)]
s <- ssa(x1, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
View(x1)
View(x)
x1 <- x[,c(6)]
s <- ssa(x1, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
dim(x1)
x2 <- vector()
for (i in 1:730){
x2(i) <- x1[i,1]
}
x3 <- c(1,2)
x3(1)
x3[1]
x2[i]<- x1[i,1]
for (i in 1:730){
x2[i]<- x1[i,1]
}
x2
s <- ssa(x2, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
summary(s)
730/30
730/7
730/28
knitr::opts_chunk$set(echo = TRUE)
x <- filter(df_day,NEWID==283)
x1 <- x[,c(6)]
x2 <- vector()
for (i in 1:730){
x2[i]<- x1[i,1]
}
x2
plot(s)
knitr::opts_chunk$set(echo = TRUE)
x <- filter(df_day,NEWID==283)
x1 <- x[,c(6)]
x2 <- vector()
for (i in 1:730){
x2[i]<- x1[i,1]
}
#x2
r <- reconstruct(s, groups = list(Trend = c(1, 4),
Seasonality = c(2:3, 5:6))) # Reconstruct into 2 series
plot(s)
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(Trend = c(1, 4),Seasonality = c(2:3, 5:6)))
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(Trend = c(1, 4)))
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(Trend = 1,Seasonality = 2：3))
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(Trend = 1,Seasonality = 2:3))
ts <- ts(matrix(c(subset$sum_actual_per_week,subset$sum_exe_per_week),107),start=1,end=107,frequency = 1)
## matrix:30*701,xxt 30*30, number of eigenvalues is 30. DECOMPOSITION.
s <- ssa(x2, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(Trend = 1,Seasonality = 2:3))
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(Trend = 1,Seasonality = 2:6))
s
# function [signalFiltered]=SSA(signal,windowLen)
# # %========================================================================
# # % signal 原始信号
# # % windowLen 窗口长度
# # % signalFiltered   重构时间序列
# # %=========================================================================
# # % Step1 : 建立轨迹矩阵
# N=length(signal);
# if windowLen>N/2;
#     windowLen=N-windowLen;
# end
# K=N-windowLen+1;
# X=zeros(windowLen,K);
# for i=1:K
#     X(1:windowLen,i)=signal(i:windowLen+i-1);
# end
# % Step 2: 奇异值分解
# S=X*X';
# [U,autoval]=eig(S);%eig返回矩阵的特征值和特征向量，U是特征向量，autoval是特征值
# [d,i]=sort(diag(autoval),'descend');
# sev=sum(d); %特征值的和,可根据占比选择有效信号
# U=U(:,i);
# V=(X')*U;
# % Step 3:分组
# I=[1:windowLen/2];%I的选择可根据信号特征选择
# Vt=V';
# rca=U(:,I)*Vt(I,:);
# % Step 4: 对交平均化重构信号
# y=zeros(N,1);
# Lp=min(windowLen,K);
# Kp=max(windowLen,K);
# %重构 1~Lp-1
# for k=0:Lp-2
#     for m=1:k+1;
#         y(k+1)=y(k+1)+(1/(k+1))*rca(m,k-m+2);
#     end
# end
# %重构 Lp~Kp
# for k=Lp-1:Kp-1
#     for m=1:Lp;
#         y(k+1)=y(k+1)+(1/(Lp))*rca(m,k-m+2);
#     end
# end
# %重构 Kp+1~N
# for k=Kp:N-1
#     for m=k-Kp+2:N-Kp+1;
#         y(k+1)=y(k+1)+(1/(N-k))*rca(m,k-m+2);
#     end
# end
#
# signalFiltered = y;
# end
# function [signalFiltered]=SSA(signal,windowLen)
# # %========================================================================
# # % signal 原始信号
# # % windowLen 窗口长度
# # % signalFiltered   重构时间序列
# # %=========================================================================
# # % Step1 : 建立轨迹矩阵
N=length(x2),
# function [signalFiltered]=SSA(signal,windowLen)
# # %========================================================================
# # % signal 原始信号
# # % windowLen 窗口长度
# # % signalFiltered   重构时间序列
# # %=========================================================================
# # % Step1 : 建立轨迹矩阵
N=length(x2)
N
windowLen=30
365/53
53/7
K=N-windowLen+1
K
X=matrix(0,windowLen,K)
for (i in 1:K){
X[1:windowLen,i] <- x2(i:windowLen+i-1)
}
X[1:windowLen,i] <- x2[i:windowLen+i-1]
for (i in 1:K){
X[1:windowLen,i] <- x2[i:windowLen+i-1]
}
for (i in 1:K){
X[1:30,i] <- x2[i:windowLen+i-1]
}
for (i in 1:K){
X[,i] <- x2[i:windowLen+i-1]
}
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
x2
View(x2)
x2 <- as.numeric(x2)
## matrix:30*701,xxt 30*30, number of eigenvalues is 30. DECOMPOSITION.
s <- ssa(x2, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
plot(r, add.original = TRUE) # Plot the reconstruction
s$sigma
s$U
r$trend
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(s, type = "vectors", idx = 1:8)
plot(s, type = "paired", idx = 2:11, plot.contrib = FALSE)
print(parestimate(s, groups = list(2:3, 4:5),
method = "pairs"))
#print(parestimate(s, groups = list(2:3, 4:5),
#  method = "pairs"))
plot(wcor(s, groups = 1:30),
scales = list(at = c(10, 20, 30)))
plot(reconstruct(s, groups = list(G12 = 2:3, G4 = 4:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
# s$U
# s$V
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, c(3:6,9)))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
plot(s, type = "vectors", idx = 1:8)
plot(s, type = "paired", idx = 2:11, plot.contrib = FALSE)
#print(parestimate(s, groups = list(2:3, 4:5),
#  method = "pairs"))
plot(wcor(s, groups = 1:30),
scales = list(at = c(10, 20, 30)))
plot(reconstruct(s, groups = list(G12 = 2:3, G4 = 4:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
plot(reconstruct(s, groups = list(G12 = 1:2, G4 = 3:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
plot(reconstruct(s, groups = list(G12 = 1, G4 = 3:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
plot(reconstruct(s, groups = list(G12 = 1, G4 = 2:5,
G6 = 6:7, G2.4 = 8:9)),
plot.method = "xyplot", layout = c(2, 2),
add.residuals = FALSE, add.original = FALSE)
summary(s)
plot(s)
s$sigma #singular values
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
r
plot(s, type = "vectors", idx = 1:8) #main eigenvalue is only one, what is it?
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:8) #main eigenvalue is only one, what is it?
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, Seasonality=c(3:8)))
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:8) #main eigenvalue is only one, what is it?
# s$U
# s$V
plot(s, type = "vectors", idx = 1:12) #main eigenvalue is only one, what is it?
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #main eigenvalue is only one, what is it?
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, Seasonality=c(3:15)))
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
#r$trend
# plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
#
plot(s, type = "paired", idx = 2:11, plot.contrib = FALSE)
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
## matrix:30*701,xxt 30*30, number of eigenvalues is 30. DECOMPOSITION.
s <- ssa(x2, L = 30, neig = NULL, kind = "1d-ssa", svd.method = "auto")
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
#Reconstruct into 2 series
r <- reconstruct(s, groups = list(trend = 1:2, Seasonality=c(3:15)))
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:30) #two main eigenvalue are trends, what is it?
#r$trend
plot(r, add.original = TRUE) # Plot the reconstruction
plot(r, add.residuals = TRUE, add.original = TRUE,
plot.method = "xyplot",
superpose = TRUE, auto.key = list(columns = 2))
# s$U
# s$V
plot(s, type = "vectors", idx = 1:15) #two main eigenvalue are trends, what is it?
knitr::opts_chunk$set(echo = TRUE)
#install.packages("leaflet")
library(leaflet)
knitr::opts_chunk$set(echo = TRUE)
#install.packages("leaflet")
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=-123.542880, lat=39.377740, popup="The birthplace of R")
m  # Print the map
